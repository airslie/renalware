// Create a timer that will poll to see if the user's session is still valid.
// If it isn't, the server returns a 401 unauthorised causing a redirect the login page.
// Note that we could in the future display a message letting them know their session
// will expired in X seconds. The controller action we hit here could be expanded to
// to render some js that would insert than into the page.
// Note we don't want to poll if we are sat on the login page anyway. For one thing on Heroku it
// would prevent a dyno sleeping, but its also a waste of resources.
//
// Note this mechanism has been superceded by the session_timeout.js stimulus controller.
//

<% if Renalware.config.session_expiry_use_previous_mechansim %>
  $(document).ready(function() {
    var login_path ="<%= Renalware::Engine.routes.url_helpers.new_user_session_path %>";
    var defaultPollFreq = <%= Renalware.config.session_timeout_polling_frequency.to_i %>;
    var frequency_s = defaultPollFreq;

    // This is a global window function so that we can call it directly from capybara tests to
    // bypass having to wait for the session polling interval to tick over.
    window.sessionTimeoutCheck = function(){
      if(window.location.pathname != login_path) {
        Rails.ajax({
          type: "GET",
          url: "<%= Renalware::Engine.routes.url_helpers.check_session_expired_path %>",
          dataType: "html",
          error: function(responseText, status, xhr) {
            if (xhr.status == 401) {
              window.location.reload()
            }
          }
        });
      }
    };

    setInterval(window.sessionTimeoutCheck, (frequency_s * 1000));
  });
<% end %>
