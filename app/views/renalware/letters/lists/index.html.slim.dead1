= content_for(:tabs) do
  = render "tabs"

= content_for(:filters) do
  .search-form.filters
    = simple_form_for q,
                      as: :q,
                      url: renalware.letters_filtered_letters_list_path(named_filter:  params[:named_filter]),
                      html: { autocomplete: "off" },
                      method: :get do |f|
      .row
        - unless filter_options.dig(:enclosures_present, :hidden)
          .small-6.medium-1.large-1.columns
            = f.input :enclosures_present,
                      as: :select,
                      label: "Enclosure",
                      input_html: { disabled: filter_options.dig(:enclosures_present, :disabled) }
        .small-6.medium-2.large-2.columns
          = f.input :state_eq,
                    collection: filter_options.dig(:state_eq, :options)&.call,
                    label: "State",
                    input_html: { disabled: filter_options.dig(:state_eq, :disabled) }
        .small-6.medium-2.large-2.columns
          = f.input :author_id_eq,
                    as: :user_picker,
                    collection: authors,
                    label: "Author",
                    input_html: { disabled: filter_options.dig(:author_id_eq, :disabled) }
        .small-6.medium-2.large-2.columns
          = f.input :created_by_id_eq,
                    as: :user_picker,
                    collection: typists,
                    label: "Typist"
        .small-6.medium-2.large-2.columns
          = f.input :letterhead_id_eq, collection: letterheads, label: "Letterhead"
        .small-6.medium-1.large-1.columns
          = f.input :page_count_in_array,
                    collection: [["1 or 2", "[1,2]"],["3 or 4", "[3,4]"]],
                    label: "Pages"
        .small-12.medium-2.large-2.columns.actions.end
          = f.submit t("helpers.submit.filter"), class: "button secondary"
          span= " or "
          = link_to t("helpers.reset"), letters_list_path

  = link_to("#", data: { "reveal-id" => "batch-print-modal" }, class: "button") do
    i.fas.fa-print
    | Batch print these letters

  #batch-print-modal.reveal-modal.medium(data-reveal)
    .modal
      .modal__header
        h1= "Batch print #{letters.total_count} letters"
        /= render "renalware/shared/modal_close_link"
      .modal__body
        .content
          / This for uses the same attributes as the filter form but when submitted will
          / queue a print job for the current search criteria.
          = simple_form_for q,
                            as: :batch,
                            url: letters_batches_path,
                            method: :post,
                            remote: true do |f|
            = f.input :enclosures_present, as: :hidden
            = f.input :state_eq, as: :hidden
            = f.input :author_id_eq, as: :hidden
            = f.input :created_by_id_eq, as: :hidden
            = f.input :letterhead_id_eq, as: :hidden
            = f.input :page_count_in_array, as: :hidden
            = f.submit "Print", class: "button", data: { disable_with: "Printing" }
            n= " or "
            = link_to "Cancel",
                "#",
                "aria-label" => "Close",
                  class: "reveal-modal-close"
      .modal__footer

= within_admin_layout(title: "Letters") do
  = render "table", letters: letters, q: q

/ The modal dialog container for the dialog which will ask the user
/ if they want to mark the letter as printed. We load this dialog via ajax.
/ See letters/completed_letters/new.html.slim for th dialog content.
/ See also
/ - letters/completed_letters/create.js.erb
/ - ./show.js.erb
/ - letters.js
/ for the complete works. Using ujs for these sort of dialog -> -> post -> page refresh
/ cycles is a bit complex and we could move to using something like stimulus
/ to keep thing a bit simpler
#letter-print-modal.reveal-modal.medium(data-reveal data-refresh-url=request.original_fullpath)
